// Generated by CoffeeScript 1.3.3
var Loop, Loops,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Loops = (function(_super) {

  __extends(Loops, _super);

  function Loops(models, options) {
    var data, event, run, _ref;
    if (models == null) {
      models = [];
    }
    if (options == null) {
      options = {};
    }
    this.model = Loop;
    data = _.union(models, _.toArray(this.localStorage.data));
    Loops.__super__.constructor.call(this, data, options);
    this.localStorage.save();
    _ref = this.events;
    for (event in _ref) {
      run = _ref[event];
      this.on(event, run);
    }
  }

  Loops.prototype.parse = 'loops';

  Loops.prototype.localStorage = new Store('loops');

  Loops.prototype.events = {
    'add': function(model) {
      return this.sync('create', model.attributes);
    },
    'remove': function(model) {
      return this.sync('delete', model.attributes);
    },
    'reset': function(model) {
      localStorage.removeItem('loops');
      return this.localStorage = new Store('loops');
    },
    'change': function(model, changes) {
      var bool, change, _results;
      _results = [];
      for (change in changes) {
        bool = changes[change];
        if (bool) {
          _results.push(this.sync('update', model.attributes));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  Loops.prototype.sync = Backbone.sync.store;

  Loops.prototype.save = function() {
    return this.localStorage.save();
  };

  return Loops;

})(Backbone.Collection);

Loop = (function(_super) {

  __extends(Loop, _super);

  function Loop(attributes, options) {
    attributes.id || (attributes.id = S4());
    attributes = _.extend({}, {
      amount: 0,
      data: new Object(),
      range: 'day',
      period: 'today'
    }, attributes);
    Loop.__super__.constructor.call(this, attributes, options);
  }

  Loop.prototype.rangeReset = function(range) {
    switch (range) {
      case 'hours':
        return function(date) {
          return +moment(date).hours();
        };
      case 'days':
        return function(date) {
          return +moment(date).sod();
        };
      case 'weeks':
        return function(date) {
          return +moment(date).sod().day(0);
        };
      case 'months':
        return function(date) {
          return +moment(date).sod().date(1);
        };
      default:
        return function(date) {
          return +date;
        };
    }
  };

  Loop.prototype.resetRange = function(point, reset) {
    var time;
    time = +point.time;
    return +moment(reset(time));
  };

  Loop.prototype.createBins = function(range) {
    var bins, diff, end, i, reset, start, _i, _name;
    reset = this[_name = "" + range + "Reset"] || (this[_name] = this.rangeReset(range));
    bins = [];
    start = reset(this.startTime);
    end = reset(this.endTime);
    diff = moment(end).diff(moment(start), range);
    if (diff === 0) {
      diff === 1;
    }
    for (i = _i = 0; 0 <= diff ? _i <= diff : _i >= diff; i = 0 <= diff ? ++_i : --_i) {
      bins.push(+moment(start).add(range, i));
    }
    return bins;
  };

  Loop.prototype.migrate = function(mappings, schemas, labels) {
    var bins, data, i, index, key, mapping, x, _i, _j, _len, _ref, _ref1;
    if (arguments.length === 0) {
      return;
    }
    data = {};
    for (key in mappings) {
      mapping = mappings[key];
      bins = labels[key];
      if (bins != null) {
        data[key] = new Array(bins.length);
        for (i = _i = 0, _ref = bins.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          data[key][i] = _.copy(_.extend({}, schemas[key], {
            label: bins[i]
          }));
        }
      } else {
        data[key] = new Array(this.modelData.length);
      }
    }
    _ref1 = this.modelData;
    for (i = _j = 0, _len = _ref1.length; _j < _len; i = ++_j) {
      x = _ref1[i];
      for (key in mappings) {
        mapping = mappings[key];
        bins = labels[key];
        if ((labels[key] != null) && (schemas[key] != null)) {
          index = bins.indexOf(mapping(x));
          if (index === -1) {
            continue;
          }
          data[key][index].points.push(x);
          if (schemas[key].sum != null) {
            data[key][index].sum += x.val;
          }
        } else {
          data[key][i] = mapping(x, i);
        }
      }
    }
    return data;
  };

  Loop.prototype.collect = function() {
    var dayBins, doy, hourBins, labels, mappings, monthBins, schemas, sod, time, val, weekBins, _ref,
      _this = this;
    this.modelData = [];
    _ref = this.get('data');
    for (time in _ref) {
      val = _ref[time];
      this.modelData.push({
        time: time,
        val: val
      });
    }
    if (this.modelData.length !== 0) {
      this.start = this.modelData[0];
      this.startTime = +this.start.time;
      this.start = this.start.val;
    } else {
      this.startTime = +new Date();
    }
    if (this.modelData.length > 1) {
      this.end = _.last(this.modelData);
      this.endTime = +this.end.time;
      this.end = this.end.val;
    }
    hourBins = d3.range(24);
    this.hoursReset = this.rangeReset('hours');
    dayBins = this.createBins('days');
    weekBins = this.createBins('weeks');
    monthBins = this.createBins('months');
    schemas = {
      today: {
        by: 'time',
        points: [],
        sum: 0
      },
      hours: {
        by: 'hour',
        points: [],
        sum: 0
      },
      days: {
        by: 'day',
        points: [],
        sum: 0
      },
      weeks: {
        by: 'week',
        points: [],
        sum: 0
      },
      months: {
        by: 'month',
        points: [],
        sum: 0
      }
    };
    doy = function(point) {
      if (point == null) {
        point = void 0;
      }
      return +moment(point).format("DDD");
    };
    sod = +moment().sod();
    mappings = {
      today: function(p) {
        time = +p.time;
        if (doy(time) !== doy()) {
          return '#!@*';
        }
        return sod;
      },
      hours: function(p) {
        return +_this.resetRange(p, _this.hoursReset);
      },
      days: function(p) {
        return +_this.resetRange(p, _this.daysReset);
      },
      weeks: function(p) {
        return +_this.resetRange(p, _this.weeksReset);
      },
      months: function(p) {
        return +_this.resetRange(p, _this.monthsReset);
      }
    };
    labels = {
      today: [+moment().sod()],
      hours: hourBins,
      days: dayBins,
      weeks: weekBins,
      months: monthBins
    };
    return this.latestData = this.migrate(mappings, schemas, labels);
  };

  Loop.prototype.collectTotals = function(data, schemappings) {
    var bin, index, mapping, prop, val, _i, _ref;
    for (index = _i = 0, _ref = data.length; 0 <= _ref ? _i < _ref : _i > _ref; index = 0 <= _ref ? ++_i : --_i) {
      bin = data[index];
      for (prop in schemappings) {
        mapping = schemappings[prop];
        val = mapping(bin, index, data);
        if (val != null) {
          bin[prop] = val;
        }
      }
    }
    return data;
  };

  return Loop;

})(Backbone.Model);
